/**
 * ESP32-A Firmware: Blade (M1) + Fixture (M2) Servo Controllers
 *
 * Controls two step/dir servos over Modbus RTU (RS-485).
 * - M1: Blade spindle (step/dir, RPM control)
 * - M2: Fixture feed (step/dir, position/velocity control)
 *
 * Hardware:
 * - Motor1 blade: STEP=GPIO32, DIR=GPIO33
 * - Motor2 fixture: STEP=GPIO25, DIR=GPIO26
 * - RS-485: TX=GPIO17, RX=GPIO16, DE/RE=GPIO4
 * - Enable lines NOT driven by MCU (external safety circuit)
 *
 * Uses ESP32 MCPWM (Motor Control PWM) hardware for jitter-free step generation.
 * Based on proven servo test parameters (10,000 pulses/rev, hardware PWM).
 */

#include <Arduino.h>
#include <ModbusRTU.h>
#include <math.h>
#include "driver/mcpwm.h"
#include "soc/mcpwm_periph.h"
#include "esp_timer.h"

// ========== Hardware Pin Definitions ==========

// M1 Blade Motor
#define M1_STEP_PIN     32
#define M1_DIR_PIN      33

// M2 Fixture Motor
#define M2_STEP_PIN     25
#define M2_DIR_PIN      26

// RS-485 Interface (UART2)
#define RS485_TX_PIN    17
#define RS485_RX_PIN    16
#define RS485_DE_RE_PIN 4

// ========== Servo Parameters (from tested sketch) ==========

// M1 Blade - Servo parameters
#define M1_PULSES_PER_REV   800   // Typical servo: 10,000 input pulses per revolution
#define M1_DIR_CW           true    // true = CW, false = CCW

// M2 Fixture - Servo parameters
#define M2_PULSES_PER_REV   800   // Typical servo: 10,000 input pulses per revolution
#define M2_DIR_FWD          true    // true = forward, false = reverse
#define M2_STEPS_PER_MM     100.0   // Calibration: pulses per mm (to be measured)

// PWM Duty cycle
#define PWM_DUTY_CYCLE      50.0    // 50% duty cycle for step pulses

// Frequency limits
#define MIN_FREQ_HZ         1.0
#define MAX_FREQ_HZ         250000.0  // 250 kHz max

// ========== Modbus Register Map ==========

// M1 Blade
#define REG_M1_CMD            0x0100
#define REG_M1_RPM            0x0101
#define REG_M1_STATUS         0x0102
#define REG_M1_RAMP_MS        0x0103
#define REG_M1_JOG_PULSES_LOW  0x0104
#define REG_M1_JOG_PULSES_HIGH 0x0105

// M2 Fixture
#define REG_M2_CMD            0x0120
#define REG_M2_VEL_MM_S_x1000 0x0121
#define REG_M2_ACCEL_MM_S2    0x0122
#define REG_M2_STATUS         0x0123
#define REG_M2_POS_MM_x1000_LOW 0x0124
#define REG_M2_POS_MM_x1000_HIGH 0x0125
#define REG_M2_JOG_VEL_MM_S_x1000 0x0126
#define REG_M2_JOG_PULSES_LOW  0x0127
#define REG_M2_JOG_PULSES_HIGH 0x0128

// Common
#define REG_FW_VERSION        0x0140
#define REG_HEARTBEAT         0x0141
#define REG_LAST_FAULT_CODE   0x0142

// ========== Command Codes ==========

// M1 Commands
#define M1_CMD_STOP         0
#define M1_CMD_RUN          1
#define M1_CMD_CLEAR_FAULT  2
#define M1_CMD_JOG_PULSES   3

// M2 Commands
#define M2_CMD_STOP         0
#define M2_CMD_FWD_UNTIL_S3 1
#define M2_CMD_REV_UNTIL_S2 2
#define M2_CMD_JOG_FWD      3
#define M2_CMD_JOG_REV      4
#define M2_CMD_CLEAR_FAULT  5
#define M2_CMD_JOG_PULSES_FWD 6
#define M2_CMD_JOG_PULSES_REV 7

// ========== Status Bits ==========

// M1 Status
#define M1_STATUS_RUNNING   (1 << 0)
#define M1_STATUS_FAULT     (1 << 1)
#define M1_STATUS_READY     (1 << 2)

// M2 Status
#define M2_STATUS_IN_MOTION (1 << 0)
#define M2_STATUS_AT_S2     (1 << 1)
#define M2_STATUS_AT_S3     (1 << 2)
#define M2_STATUS_FAULT     (1 << 3)
#define M2_STATUS_HOMED     (1 << 4)

// ========== Constants ==========

#define FIRMWARE_VERSION    0x0101  // v1.1 (updated with MCPWM)
#define MODBUS_SLAVE_ID     2       // ESP32-A ID
#define MODBUS_BAUD         115200

// ========== Global Variables ==========

ModbusRTU modbus;

// Modbus holding registers (sparse array)
uint16_t holdingRegs[512];

// M1 Blade Motor State
struct {
    uint16_t cmd;
    uint16_t rpm_target;
    uint16_t ramp_ms;
    uint16_t status;
    bool running;
    double current_freq_hz;
    uint32_t jog_pulses_target;
    bool jogging;
    uint64_t jog_stop_time_us;
} m1;

// M2 Fixture Motor State
struct {
    uint16_t cmd;
    uint16_t vel_mm_s_x1000;
    uint16_t accel_mm_s2;
    uint16_t jog_vel_mm_s_x1000;
    uint16_t status;
    bool in_motion;
    int32_t position_mm_x1000;  // Position in mm×1000
    bool direction;             // true = forward
    double current_freq_hz;
    uint32_t jog_pulses_target;
    bool jogging_pulses;
    bool jog_direction_forward;
    uint64_t jog_stop_time_us;
} m2;

// Heartbeat
uint32_t lastHeartbeatUpdate = 0;
uint16_t heartbeat = 0;

// ========== Function Prototypes ==========

void setupModbus();
void setupMCPWM();
void processM1Command();
void processM2Command();
void updateHeartbeat();
void updateJogTimers();
uint16_t readHoldingRegister(TRegister* reg, uint16_t val);
void writeHoldingRegister(uint16_t address, uint16_t value);

// MCPWM control functions
void m1_pwm_set_frequency(double freq_hz);
void m1_pwm_enable(bool enable);
void m2_pwm_set_frequency(double freq_hz);
void m2_pwm_enable(bool enable);

// ========== Setup ==========

void setup() {
    // Serial for debugging
    Serial.begin(115200);
    delay(500);
    Serial.println("\n\nESP32-A: Blade + Fixture Controller (MCPWM)");
    Serial.println("Firmware v1.1");
    Serial.printf("M1 pulses/rev: %d\n", M1_PULSES_PER_REV);
    Serial.printf("M2 pulses/rev: %d\n", M2_PULSES_PER_REV);
    Serial.printf("M2 steps/mm: %.1f\n", M2_STEPS_PER_MM);

    // Configure GPIO pins
    pinMode(M1_DIR_PIN, OUTPUT);
    pinMode(M2_DIR_PIN, OUTPUT);
    pinMode(RS485_DE_RE_PIN, OUTPUT);

    digitalWrite(M1_DIR_PIN, M1_DIR_CW ? HIGH : LOW);
    digitalWrite(M2_DIR_PIN, LOW);  // Will be set dynamically
    digitalWrite(RS485_DE_RE_PIN, LOW);  // Receive mode

    // Initialize state
    memset(&m1, 0, sizeof(m1));
    memset(&m2, 0, sizeof(m2));
    memset(holdingRegs, 0, sizeof(holdingRegs));

    m1.status = M1_STATUS_READY;
    m2.status = M2_STATUS_HOMED;  // Assume homed at startup

    // Initialize firmware version register
    holdingRegs[REG_FW_VERSION] = FIRMWARE_VERSION;

    // Setup MCPWM hardware
    setupMCPWM();

    // Setup Modbus RTU slave
    setupModbus();

    Serial.println("Initialization complete");
}

// ========== Main Loop ==========

void loop() {
    // Process Modbus requests
    modbus.task();

    // Update jog timers
    updateJogTimers();

    // Update heartbeat
    updateHeartbeat();

    // Small yield to avoid watchdog
    yield();
}

// ========== MCPWM Setup ==========

void setupMCPWM() {
    // M1 Blade: MCPWM Unit 0, Timer 0, Operator A (MCPWM0A)
    mcpwm_gpio_init(MCPWM_UNIT_0, MCPWM0A, M1_STEP_PIN);

    mcpwm_config_t m1_config;
    m1_config.frequency    = 1000;  // Initial frequency (will be changed)
    m1_config.cmpr_a       = 0.0;   // Start stopped
    m1_config.cmpr_b       = 0.0;
    m1_config.counter_mode = MCPWM_UP_COUNTER;
    m1_config.duty_mode    = MCPWM_DUTY_MODE_0;

    mcpwm_init(MCPWM_UNIT_0, MCPWM_TIMER_0, &m1_config);

    // M2 Fixture: MCPWM Unit 0, Timer 1, Operator A (MCPWM1A)
    mcpwm_gpio_init(MCPWM_UNIT_0, MCPWM1A, M2_STEP_PIN);

    mcpwm_config_t m2_config;
    m2_config.frequency    = 1000;  // Initial frequency
    m2_config.cmpr_a       = 0.0;   // Start stopped
    m2_config.cmpr_b       = 0.0;
    m2_config.counter_mode = MCPWM_UP_COUNTER;
    m2_config.duty_mode    = MCPWM_DUTY_MODE_0;

    mcpwm_init(MCPWM_UNIT_0, MCPWM_TIMER_1, &m2_config);

    Serial.println("MCPWM initialized for M1 and M2");
}

// ========== Modbus Setup ==========

void setupModbus() {
    // Configure Serial2 for RS-485
    Serial2.begin(MODBUS_BAUD, SERIAL_8N1, RS485_RX_PIN, RS485_TX_PIN);

    // Setup Modbus RTU slave
    modbus.begin(&Serial2);
    modbus.slave(MODBUS_SLAVE_ID);

    // Register Modbus holding registers and callbacks
    modbus.addHreg(REG_M1_CMD, 0, 0x200);
    modbus.onGetHreg(REG_M1_CMD, readHoldingRegister, 0x200);
    modbus.onSetHreg(REG_M1_CMD, [](TRegister* reg, uint16_t val) {
        writeHoldingRegister(reg->address.address, val);
        return val;
    }, 0x200);

    Serial.printf("Modbus RTU slave ID=%d, baud=%d\n", MODBUS_SLAVE_ID, MODBUS_BAUD);
}

// ========== Modbus Register Access ==========

uint16_t readHoldingRegister(TRegister* reg, uint16_t val) {
    // Read from shadow register or live status
    // Get address from register offset
    uint16_t address = reg->address.address;

    switch (address) {
        case REG_M1_STATUS:
            return m1.status;

        case REG_M1_JOG_PULSES_LOW:
            return (uint16_t)(m1.jog_pulses_target & 0xFFFF);

        case REG_M1_JOG_PULSES_HIGH:
            return (uint16_t)((m1.jog_pulses_target >> 16) & 0xFFFF);

        case REG_M2_STATUS:
            return m2.status;

        case REG_M2_JOG_PULSES_LOW:
            return (uint16_t)(m2.jog_pulses_target & 0xFFFF);

        case REG_M2_JOG_PULSES_HIGH:
            return (uint16_t)((m2.jog_pulses_target >> 16) & 0xFFFF);

        case REG_M2_POS_MM_x1000_LOW:
            return (uint16_t)(m2.position_mm_x1000 & 0xFFFF);

        case REG_M2_POS_MM_x1000_HIGH:
            return (uint16_t)((m2.position_mm_x1000 >> 16) & 0xFFFF);

        case REG_HEARTBEAT:
            return heartbeat;

        default:
            return holdingRegs[address];
    }
}

void writeHoldingRegister(uint16_t address, uint16_t value) {
    holdingRegs[address] = value;

    // Handle command registers
    switch (address) {
        case REG_M1_CMD:
            m1.cmd = value;
            processM1Command();
            break;

        case REG_M1_RPM:
            m1.rpm_target = value;
            break;

        case REG_M1_RAMP_MS:
            m1.ramp_ms = value;
            break;

        case REG_M1_JOG_PULSES_LOW:
            m1.jog_pulses_target = (m1.jog_pulses_target & 0xFFFF0000UL) | value;
            break;

        case REG_M1_JOG_PULSES_HIGH:
            m1.jog_pulses_target = (m1.jog_pulses_target & 0x0000FFFFUL) | ((uint32_t)value << 16);
            break;

        case REG_M2_CMD:
            m2.cmd = value;
            processM2Command();
            break;

        case REG_M2_VEL_MM_S_x1000:
            m2.vel_mm_s_x1000 = value;
            break;

        case REG_M2_ACCEL_MM_S2:
            m2.accel_mm_s2 = value;
            break;

        case REG_M2_JOG_VEL_MM_S_x1000:
            m2.jog_vel_mm_s_x1000 = value;
            break;

        case REG_M2_JOG_PULSES_LOW:
            m2.jog_pulses_target = (m2.jog_pulses_target & 0xFFFF0000UL) | value;
            break;

        case REG_M2_JOG_PULSES_HIGH:
            m2.jog_pulses_target = (m2.jog_pulses_target & 0x0000FFFFUL) | ((uint32_t)value << 16);
            break;
    }
}

// ========== M1 Blade Motor Control ==========

void processM1Command() {
    switch (m1.cmd) {
        case M1_CMD_STOP:
            Serial.println("M1: STOP");
            m1.running = false;
            m1.jogging = false;
            m1.status &= ~M1_STATUS_RUNNING;
            m1_pwm_enable(false);
            break;

        case M1_CMD_RUN:
            Serial.printf("M1: RUN at %u RPM\n", m1.rpm_target);
            m1.jogging = false;
            if (m1.rpm_target > 0) {
                // Calculate frequency: (pulses/rev * RPM) / 60
                double freq = (double)M1_PULSES_PER_REV * (double)m1.rpm_target / 60.0;

                // Clamp to safe range
                if (freq < MIN_FREQ_HZ) freq = MIN_FREQ_HZ;
                if (freq > MAX_FREQ_HZ) freq = MAX_FREQ_HZ;

                Serial.printf("M1: Step frequency = %.1f Hz\n", freq);

                m1.current_freq_hz = freq;
                m1_pwm_set_frequency(freq);
                m1_pwm_enable(true);

                m1.running = true;
                m1.status |= M1_STATUS_RUNNING;
            }
            break;

        case M1_CMD_JOG_PULSES:
            Serial.printf("M1: JOG_PULSES %u at %u RPM\n", m1.jog_pulses_target, m1.rpm_target);
            m1.running = false;
            m1.jogging = false;
            if (m1.rpm_target > 0 && m1.jog_pulses_target > 0) {
                double freq = (double)M1_PULSES_PER_REV * (double)m1.rpm_target / 60.0;

                if (freq < MIN_FREQ_HZ) freq = MIN_FREQ_HZ;
                if (freq > MAX_FREQ_HZ) freq = MAX_FREQ_HZ;

                double duration_s = (double)m1.jog_pulses_target / freq;
                uint64_t duration_us = (uint64_t)(duration_s * 1000000.0);
                if (duration_us == 0) {
                    duration_us = 1;
                }

                Serial.printf("M1: Jog frequency = %.1f Hz, duration %.3f s\n", freq, duration_s);

                m1.current_freq_hz = freq;
                m1_pwm_set_frequency(freq);
                m1_pwm_enable(true);

                m1.running = true;
                m1.jogging = true;
                m1.status |= M1_STATUS_RUNNING;
                m1.jog_stop_time_us = esp_timer_get_time() + duration_us;
            } else {
                Serial.println("M1: JOG_PULSES ignored (invalid rpm or pulse count)");
            }
            break;

        case M1_CMD_CLEAR_FAULT:
            Serial.println("M1: CLEAR_FAULT");
            m1.status &= ~M1_STATUS_FAULT;
            break;
    }

    // Clear command after processing
    m1.cmd = 0;
}

void m1_pwm_set_frequency(double freq_hz) {
    // Reconfigure MCPWM Timer 0 with new frequency
    mcpwm_set_frequency(MCPWM_UNIT_0, MCPWM_TIMER_0, (uint32_t)freq_hz);
}

void m1_pwm_enable(bool enable) {
    if (enable) {
        // Set duty cycle to 50%
        mcpwm_set_duty(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, PWM_DUTY_CYCLE);
        mcpwm_set_duty_type(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, MCPWM_DUTY_MODE_0);
    } else {
        // Set duty cycle to 0% (stop)
        mcpwm_set_duty(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, 0.0);
        mcpwm_set_duty_type(MCPWM_UNIT_0, MCPWM_TIMER_0, MCPWM_OPR_A, MCPWM_DUTY_MODE_0);
        m1.jogging = false;
    }
}

// ========== M2 Fixture Motor Control ==========

void processM2Command() {
    switch (m2.cmd) {
        case M2_CMD_STOP:
            Serial.println("M2: STOP");
            m2.in_motion = false;
            m2.jogging_pulses = false;
            m2.status &= ~M2_STATUS_IN_MOTION;
            m2_pwm_enable(false);
            break;

        case M2_CMD_FWD_UNTIL_S3:
            Serial.println("M2: FWD_UNTIL_S3");
            // Set direction forward
            digitalWrite(M2_DIR_PIN, M2_DIR_FWD ? HIGH : LOW);
            m2.direction = true;
            m2.jogging_pulses = false;

            // Calculate frequency from velocity (mm/s × 1000)
            {
                double vel_mm_s = (double)m2.vel_mm_s_x1000 / 1000.0;
                double freq = vel_mm_s * M2_STEPS_PER_MM;

                // Clamp to safe range
                if (freq < MIN_FREQ_HZ) freq = MIN_FREQ_HZ;
                if (freq > MAX_FREQ_HZ) freq = MAX_FREQ_HZ;

                Serial.printf("M2 FWD: vel=%.1f mm/s, freq=%.1f Hz\n", vel_mm_s, freq);

                m2.current_freq_hz = freq;
                m2_pwm_set_frequency(freq);
                m2_pwm_enable(true);

                m2.in_motion = true;
                m2.status |= M2_STATUS_IN_MOTION;
                m2.status &= ~M2_STATUS_AT_S3;
            }
            break;

        case M2_CMD_REV_UNTIL_S2:
            Serial.println("M2: REV_UNTIL_S2");
            // Set direction reverse
            digitalWrite(M2_DIR_PIN, M2_DIR_FWD ? LOW : HIGH);
            m2.direction = false;
            m2.jogging_pulses = false;

            // Calculate frequency from velocity
            {
                double vel_mm_s = (double)m2.vel_mm_s_x1000 / 1000.0;
                double freq = vel_mm_s * M2_STEPS_PER_MM;

                // Clamp to safe range
                if (freq < MIN_FREQ_HZ) freq = MIN_FREQ_HZ;
                if (freq > MAX_FREQ_HZ) freq = MAX_FREQ_HZ;

                Serial.printf("M2 REV: vel=%.1f mm/s, freq=%.1f Hz\n", vel_mm_s, freq);

                m2.current_freq_hz = freq;
                m2_pwm_set_frequency(freq);
                m2_pwm_enable(true);

                m2.in_motion = true;
                m2.status |= M2_STATUS_IN_MOTION;
                m2.status &= ~M2_STATUS_AT_S2;
            }
            break;

        case M2_CMD_JOG_FWD:
        case M2_CMD_JOG_REV:
        {
            Serial.printf("M2: JOG %s\n", (m2.cmd == M2_CMD_JOG_FWD) ? "FWD" : "REV");

            // Set direction
            bool jog_fwd = (m2.cmd == M2_CMD_JOG_FWD);
            digitalWrite(M2_DIR_PIN, jog_fwd ? (M2_DIR_FWD ? HIGH : LOW) : (M2_DIR_FWD ? LOW : HIGH));
            m2.direction = jog_fwd;
            m2.jogging_pulses = false;

            // Use jog velocity
            double jog_vel_mm_s = (double)m2.jog_vel_mm_s_x1000 / 1000.0;
            double freq = jog_vel_mm_s * M2_STEPS_PER_MM;

            // Clamp to safe range
            if (freq < MIN_FREQ_HZ) freq = MIN_FREQ_HZ;
            if (freq > MAX_FREQ_HZ) freq = MAX_FREQ_HZ;

            Serial.printf("M2 JOG: vel=%.1f mm/s, freq=%.1f Hz\n", jog_vel_mm_s, freq);

            m2.current_freq_hz = freq;
            m2_pwm_set_frequency(freq);
            m2_pwm_enable(true);

            m2.in_motion = true;
            m2.status |= M2_STATUS_IN_MOTION;
            break;
        }

        case M2_CMD_JOG_PULSES_FWD:
        case M2_CMD_JOG_PULSES_REV:
        {
            bool jog_fwd = (m2.cmd == M2_CMD_JOG_PULSES_FWD);
            Serial.printf("M2: JOG_PULSES %s (%u pulses)\n", jog_fwd ? "FWD" : "REV", m2.jog_pulses_target);

            if (m2.jog_pulses_target > 0 && m2.jog_vel_mm_s_x1000 > 0) {
                double jog_vel_mm_s = (double)m2.jog_vel_mm_s_x1000 / 1000.0;
                double freq = jog_vel_mm_s * M2_STEPS_PER_MM;

                if (freq < MIN_FREQ_HZ) freq = MIN_FREQ_HZ;
                if (freq > MAX_FREQ_HZ) freq = MAX_FREQ_HZ;

                double duration_s = (double)m2.jog_pulses_target / freq;
                uint64_t duration_us = (uint64_t)(duration_s * 1000000.0);
                if (duration_us == 0) {
                    duration_us = 1;
                }

                // Set direction
                digitalWrite(M2_DIR_PIN, jog_fwd ? (M2_DIR_FWD ? HIGH : LOW) : (M2_DIR_FWD ? LOW : HIGH));
                m2.direction = jog_fwd;

                Serial.printf("M2: Jog pulses freq=%.1f Hz, duration %.3f s\n", freq, duration_s);

                m2.current_freq_hz = freq;
                m2_pwm_set_frequency(freq);
                m2_pwm_enable(true);

                m2.in_motion = true;
                m2.status |= M2_STATUS_IN_MOTION;
                if (jog_fwd) {
                    m2.status &= ~M2_STATUS_AT_S2;
                } else {
                    m2.status &= ~M2_STATUS_AT_S3;
                }

                m2.jogging_pulses = true;
                m2.jog_direction_forward = jog_fwd;
                m2.jog_stop_time_us = esp_timer_get_time() + duration_us;
            } else {
                Serial.println("M2: JOG_PULSES ignored (invalid velocity or pulse count)");
                m2_pwm_enable(false);
                m2.in_motion = false;
                m2.jogging_pulses = false;
                m2.status &= ~M2_STATUS_IN_MOTION;
            }
            break;
        }

        case M2_CMD_CLEAR_FAULT:
            Serial.println("M2: CLEAR_FAULT");
            m2.status &= ~M2_STATUS_FAULT;
            break;
    }

    // Clear command after processing
    m2.cmd = 0;
}

void m2_pwm_set_frequency(double freq_hz) {
    // Reconfigure MCPWM Timer 1 with new frequency
    mcpwm_set_frequency(MCPWM_UNIT_0, MCPWM_TIMER_1, (uint32_t)freq_hz);
}

void m2_pwm_enable(bool enable) {
    if (enable) {
        // Set duty cycle to 50%
        mcpwm_set_duty(MCPWM_UNIT_0, MCPWM_TIMER_1, MCPWM_OPR_A, PWM_DUTY_CYCLE);
        mcpwm_set_duty_type(MCPWM_UNIT_0, MCPWM_TIMER_1, MCPWM_OPR_A, MCPWM_DUTY_MODE_0);
    } else {
        // Set duty cycle to 0% (stop)
        mcpwm_set_duty(MCPWM_UNIT_0, MCPWM_TIMER_1, MCPWM_OPR_A, 0.0);
        mcpwm_set_duty_type(MCPWM_UNIT_0, MCPWM_TIMER_1, MCPWM_OPR_A, MCPWM_DUTY_MODE_0);
        m2.jogging_pulses = false;
    }
}

void updateJogTimers() {
    uint64_t now_us = esp_timer_get_time();

    if (m1.jogging && now_us >= m1.jog_stop_time_us) {
        Serial.println("M1: Jog complete");
        m1_pwm_enable(false);
        m1.running = false;
        m1.jogging = false;
        m1.status &= ~M1_STATUS_RUNNING;
    }

    if (m2.jogging_pulses && now_us >= m2.jog_stop_time_us) {
        Serial.println("M2: Jog pulses complete");
        m2_pwm_enable(false);
        m2.in_motion = false;
        m2.jogging_pulses = false;
        m2.status &= ~M2_STATUS_IN_MOTION;

        double pulses = (double)m2.jog_pulses_target;
        double delta_mm = pulses / M2_STEPS_PER_MM;
        double delta_mm_x1000_d = delta_mm * 1000.0;
        int32_t delta_mm_x1000 = (int32_t)(delta_mm_x1000_d >= 0.0 ? delta_mm_x1000_d + 0.5 : delta_mm_x1000_d - 0.5);

        if (m2.jog_direction_forward) {
            m2.position_mm_x1000 += delta_mm_x1000;
            m2.status &= ~M2_STATUS_AT_S2;
            m2.status |= M2_STATUS_AT_S3;
        } else {
            m2.position_mm_x1000 -= delta_mm_x1000;
            m2.status &= ~M2_STATUS_AT_S3;
            m2.status |= M2_STATUS_AT_S2;
        }
    }
}

// ========== Heartbeat ==========

void updateHeartbeat() {
    uint32_t now = millis();

    if (now - lastHeartbeatUpdate >= 1000) {
        heartbeat++;
        holdingRegs[REG_HEARTBEAT] = heartbeat;
        lastHeartbeatUpdate = now;
    }
}
